
```{r}
library(shiny)
library(shinyWidgets)
library(ClustAssess)
library(ggplot2)
library(dplyr)
library(plotly)
library(RColorBrewer)
devtools::load_all()
```

```{r}
cList <- list(
  c(
    "grey85", "#FFF7EC", "#FEE8C8", "#FDD49E", "#FDBB84",
    "#FC8D59", "#EF6548", "#D7301F", "#B30000", "#7F0000"
  ),
  c(
    "#4575B4", "#74ADD1", "#ABD9E9", "#E0F3F8", "#FFFFBF",
    "#FEE090", "#FDAE61", "#F46D43", "#D73027"
  )[c(1, 1:9, 9)],
  c(
    "#FDE725", "#AADC32", "#5DC863", "#27AD81", "#21908C",
    "#2C728E", "#3B528B", "#472D7B", "#440154"
  )
)
names(cList) <- c("White-Red", "Blue-Yellow-Red", "Yellow-Green-Purple")
```

```{r}
load("expression_matrix.rda")
load("stab_obj.rda")
load("metadata.rda")
```

```{r}
empty_ggplot <- function() {
  ggplot2::ggplot() +
    ggplot2::theme_void()
}

expression_ggplot <- function(embedding, expression) {
  ggplot2::ggplot(
    data.frame(embedding),
    aes(x = .data$UMAP_1, y = .data$UMAP_2, color = expression)
  ) +
    ggplot2::geom_point() +
    ggplot2::theme_bw() +
    ggplot2::scale_color_gradientn("", colors = cList[[1]]) +
    ggplot2::guides(color = ggplot2::guide_colorbar(barwidth = 15)) +
    ggplot2::theme(legend.position = "bottom")
}

color_ggplot <- function(embedding, color_info) {
  ggplot2::ggplot(
    data.frame(embedding),
    aes(
      x = .data$UMAP_1,
      y = .data$UMAP_2,
      color = color_info
    )
  ) +
    ggplot2::geom_point() +
    ggplot2::theme_bw()
}

voting_scheme_ggplot <- function(embedding,
                                 selected_genes,
                                 expression_threshold) {
  umap_df <- data.frame(embedding)
  n_expressed_genes <- rep(0, ncol(expression_matrix))
  expression_threshold <- as.numeric(expression_threshold)
  for (gene in selected_genes) {
    n_expressed_genes <- n_expressed_genes + (expression_matrix[gene, ] > expression_threshold)
  }

  mask <- (n_expressed_genes >= length(selected_genes))

  ggplot2::ggplot() +
    ggplot2::geom_point(
      data = umap_df[!mask, ],
      mapping = aes(x = .data$UMAP_1, .data$UMAP_2),
      color = "#C3C3C3"
    ) +
    ggplot2::geom_point(
      data = umap_df[mask, ],
      mapping = aes(x = .data$UMAP_1, .data$UMAP_2),
      color = "red"
    ) +
    ggplot2::theme_bw()
}

metadata_ggplot <- function(embedding,
                            metadata_value) {
  color_info <- metadata[[metadata_value]]
  if (length(unique(color_info)) > 50) {
    color_info <- as.numeric(factor(color_info))
  } else {
    color_info <- factor(color_info)
  }

  color_ggplot(embedding, color_info)
}
```

```{r}
feature_config <- names(stab_obj$feature_importance$steps_stability)
steps <- lapply(feature_config, function(x) {
  names(stab_obj$feature_importance$steps_stability[[x]])
})
names(steps) <- feature_config
feature_config_display <- sapply(feature_config, function(x) {
  strsplit(x, "_")[[1]]
})

feature_config_display
strsplit(feature_config[1], "_")[[1]]
feature_used_resolution_vals <- names(stab_obj$feature_importance[[1]][[1]][[1]])
```

```{r}


# ui_dimensionality_reduction_inputs <- function(id) {
#   ns <- NS(id)
#
#   tagList(
#     selectInput(ns("feature_configs"), "Feature names", feature_config, selected = feature_config, multiple = TRUE),
#     sliderInput(ns("boxplot_width"), "Boxplot width", min = 0.00, max = 1.00, value = 0.40),
#     sliderInput(ns("dodge_width"), "Dodge width", min = 0.00, max = 1.00, value = 0.70),
#     sliderInput(ns("text_size"), "Text size", min = 0.10, max = 25.00, value = 4.00),
#   )
# }
#
# ui_dimensionali
#

ui_dimensionality_stability <- function(id) {
  ns <- NS(id)

  tagList(
    selectInput(ns("feature_configs"), "Feature names", feature_config, selected = feature_config, multiple = TRUE),
    uiOutput(ns("stepchoosing")),
    h2("ECC per individual resolution values"),
    fluidRow(
      column(
        8,
        plotOutput(ns("boxplot_ecc"),
          hover = hoverOpts(id = ns("ecc_hover"), delayType = "throttle"),
          click = ns("ecc_click"),
          height = "500px",
        ),
      ),
      column(
        4,
        fluidRow(
          textOutput(ns("boxplot_ecc_info")),
          tableOutput(ns("table_ecc_info")),
          plotOutput(ns("umap_ecc"), height = "350px"),
        )
      )
    ),
    h2("Incremental ECS per individual resolution values"),
    fluidRow(
      column(
        8,
        plotOutput(ns("boxplot_incr"))
      ),
      column(
        4,
        sliderTextInput(ns("resolution"), "Resolution", choices = feature_used_resolution_vals, selected = feature_used_resolution_vals[1]),
        sliderInput(ns("boxplot_width"), "Boxplot width", min = 0.00, max = 1.00, value = 0.40),
        sliderInput(ns("dodge_width"), "Dodge width", min = 0.00, max = 1.00, value = 0.70),
        sliderInput(ns("text_size"), "Text size", min = 0.10, max = 25.00, value = 4.00),
      )
    ),
    hr(),
    h2("Overall stability"),
    plotOutput(ns("overall_boxplot_ecc")),
    h2("Overall incremental stability"),
    plotOutput(ns("overall_boxplot_incremental"))
  )
}

ui_dimensionality_distribution_plots <- function(id) {
  ns <- NS(id)

  tagList(
    selectInput(ns("feature_type"), "Feature names", feature_config),
    selectInput(ns("feature_steps"), "Feature set size", NULL),
    hr(),
    fluidRow(
      column(
        6,
        selectInput(ns("gene_expr"), "Gene name(s)", choices = rownames(expression_matrix)[1:3000], selected = rownames(expression_matrix)[1], multiple = TRUE)
      ),
      column(
        6,
        conditionalPanel(
          condition = "input.gene_expr.length > 1",
          sliderInput(ns("expr_threshold"), "Gene expression threshold", min = 0, max = 10, value = 0.1),
          ns = ns
        )
      )
    ),
    plotOutput(ns("umap_gene")),
    selectInput(ns("metadata"), "Metadata", choices = colnames(metadata), selected = colnames(metadata)[1]),
    plotOutput(ns("umap_metadata"))
  )
}

ui_dimensionality_recommendation <- function(id) {
  ns <- NS(id)

  tagList(
    radioButtons(
      ns("radio_feature_type"),
      label = "Choose the feature type for the downstream analysis:",
      choices = feature_config,
      selected = feature_config[1],
      width = "100%"
    ),
    radioButtons(
      inputId = ns("radio_feature_size"),
      label = "Choose the size of the feature set for the downstream analysis:",
      choices = names(stab_obj[[feature_config[1]]]),
      selected = NULL,
      width = "100%"
    ),
    uiOutput(ns("recommendation")),
    actionButton(ns("fix_feature_button"), "Choose this combination")
  )
}
```

```{r}
ui_dimensionality_reduction <- function(id) {
  ns <- NS(id)

  tabPanel(
    "Dimensionality Reduction",
    h2("Assessing the stability of the dimensionality reduction"),
    ui_dimensionality_stability(ns("stability")),
    fluidRow(
      column(
        6,
        ui_dimensionality_distribution_plots(ns("distribution_left"))
      ),
      column(
        6,
        ui_dimensionality_distribution_plots(ns("distribution_right"))
      )
    ),
    ui_dimensionality_recommendation(ns("recommend"))
  )
}

ui_graph_construction <- function(id) {
  ns <- NS(id)

  tabPanel(
    "Graph Construction",
    h2("asdf")
  )
}

ui_graph_clustering <- function(id) {
  ns <- NS(id)

  tabPanel(
    "Graph Clustering",
    uiOutput(ns("selected_conf")),
    uiOutput(ns("header1")),
    fluidRow(
      column(
        8,
        plotOutput(ns("boxplot_per_value")),
      ),
      column(
        4,
        plotOutput(ns("umap_config"))
      )
    ),
    uiOutput(ns("header2")),
    fluidRow(
      column(
        6,
        plotOutput(ns("boxplot_overall_resolution"))
      ),
      column(
        6,
        plotOutput(ns("boxplot_overall_k"))
      )
    ),
    uiOutput(ns("header3")),
    plotOutput(ns("k_resolution")),
    uiOutput(ns("header4")),
    plotOutput(ns("k_stability"))
  )
}
```

```{r, fig.width=10, fig.height = 6}
```
```{r}
```


```{r}
server_dimensionality_stability <- function(id, panel_id) {
  moduleServer(
    id,
    function(input, output, session) {
      selected_configs <- reactive(input$feature_configs)

      ecc_mouse_hover <- reactiveVal(c(NA, NA))
      observeEvent(input$ecc_hover, {
        # FIXME for far right values, it doesn't detect a step
        if (is.null(input$ecc_hover)) {
          return()
        }
        x <- input$ecc_hover$x
        # y <- input$ecc_hover$y
        min_step <- min(as.numeric(boxplot_ecc_df()$step_index))
        max_step <- max(as.numeric(boxplot_ecc_df()$step_index))
        nconfigs <- length(selected_configs())
        chosen_step <- NULL
        chosen_config <- NULL

        for (steps_intervals in seq(from = min_step - 0.5, to = max_step - 0.5, by = 1)) {
          if (x < steps_intervals + 1) {
            chosen_step <- steps_intervals + 0.5
            break
          }
        }

        if (is.null(chosen_step)) {
          chosen_step <- max_step
        }

        for (i in seq_len(nconfigs)) {
          if (x < (steps_intervals + i / nconfigs)) {
            chosen_config <- i
            break
          }
        }

        if (is.null(chosen_config)) {
          chosen_config <- nconfigs
        }

        ecc_mouse_hover(c(chosen_step, chosen_config))
      })

      ecc_mouse_click <- reactiveVal(c(NA, NA))

      observeEvent(input$ecc_click, {
        if (!is.null(input$ecc_click)) {
          ecc_mouse_click(ecc_mouse_hover())
        }
      })

      output$boxplot_ecc_info <- renderText({
        if (is.na(ecc_mouse_hover()[1])) {
          return("")
        }

        feature_type <- names(current_feature_obj()$steps_stability)[ecc_mouse_hover()[2]]
        nfeatures <- names(current_feature_obj()$steps_stability[[ecc_mouse_hover()[2]]])[ecc_mouse_hover()[1]]
        glue::glue("The ECC summary for {feature_type} - {nfeatures} and resolution {input$resolution}.\n
        Click if you want to visualise the UMAP distribution.")
      })

      output$table_ecc_info <- renderTable({
        if (is.na(ecc_mouse_hover()[1])) {
          return()
        }
        summary_ecc <- fivenum(current_feature_obj()$steps_stability[[ecc_mouse_hover()[2]]][[ecc_mouse_hover()[1]]][[input$resolution]]$ecc)
        data.frame(
          min = summary_ecc[1],
          Q1 = summary_ecc[2],
          median = summary_ecc[3],
          Q3 = summary_ecc[4],
          max = summary_ecc[5]
        )
      })

      output$stepchoosing <- renderUI({
        ns <- session$ns
        i <- 1
        ret_list <- list()
        for (conf in input$feature_configs) {
          ret_list[[i]] <- selectInput(ns(paste0("nsteps_", i)),
            paste("Nsteps for", conf),
            choices = names(stab_obj$feature_importance$steps_stability[[conf]]),
            selected = names(stab_obj$feature_importance$steps_stability[[conf]]),
            multiple = TRUE
          )
          i <- i + 1
        }
        ret_list
      })

      current_feature_obj <- reactive({
        if (is.null(selected_configs())[1]) {
          return(NULL)
        }

        for (i in seq_along(selected_configs())) {
          if (is.null(input[[glue::glue("nsteps_{i}")]])[1]) {
            return(NULL)
          }
        }

        steps_stability <- lapply(seq_along(selected_configs()), function(i) {
          steps_names <- names(stab_obj$feature_importance$steps_stability[[i]])
          chosen_steps <- steps_names %in% input[[paste0("nsteps_", i)]]
          chosen_steps <- steps_names[chosen_steps]
          stab_obj$feature_importance$steps_stability[[i]][chosen_steps]
        })
        names(steps_stability) <- selected_configs()

        incremental_stability <- lapply(seq_along(selected_configs()), function(i) {
          kept_steps <- c()
          chosen_steps <- input[[paste0("nsteps_", i)]]

          if (length(chosen_steps) == 0) {
            return(list())
          }

          for (j in seq_len(length(chosen_steps) - 1)) {
            checked_steps <- paste(chosen_steps[j], chosen_steps[j + 1], sep = "-")
            if (checked_steps %in% names(stab_obj$feature_importance$incremental_stability[[i]])) {
              kept_steps <- c(kept_steps, checked_steps)
            }
          }

          stab_obj$feature_importance$incremental_stability[[i]][kept_steps]
        })
        names(incremental_stability) <- selected_configs()

        list(
          steps_stability = steps_stability,
          incremental_stability = incremental_stability
        )
      })

      boxplot_ecc_df <- reactive({
        plot_feature_per_resolution_stability_boxplot(current_feature_obj(),
          resolution = input$resolution,
          return_df = TRUE
        )
      })

      output$boxplot_ecc <- renderPlot({
        if (length(selected_configs()) == 0) {
          return(empty_ggplot())
        }

        if (is.null(current_feature_obj())) {
          return(empty_ggplot())
        }

        plot_feature_per_resolution_stability_boxplot(current_feature_obj(),
          resolution = input$resolution,
          text_size = input$text_size,
          boxplot_width = input$boxplot_width,
          dodge_width = input$dodge_width
        ) + ggplot2::theme(legend.position = "bottom")
      })

      output$boxplot_incr <- renderPlot({
        if (length(selected_configs()) == 0) {
          return(empty_ggplot())
        }

        if (is.null(current_feature_obj())) {
          return(empty_ggplot())
        }

        for (conf in selected_configs()) {
          if (length(names(current_feature_obj()$incremental_stability[[conf]])) == 0) {
            return(empty_ggplot())
          }
        }
        plot_feature_per_resolution_stability_incremental(current_feature_obj(),
          resolution = input$resolution,
          text_size = input$text_size,
          boxplot_width = input$boxplot_width,
          dodge_width = input$dodge_width
        )
      })

      output$umap_ecc <- renderPlot({
        if (is.na(ecc_mouse_click()[1])) {
          return(empty_ggplot())
        }

        if (is.null(current_feature_obj())) {
          return(empty_ggplot())
        }

        config_name <- selected_configs()[ecc_mouse_click()[2]]
        step_index <- names(current_feature_obj()$steps_stability[[config_name]])[ecc_mouse_click()[1]]
        ecc <- current_feature_obj()$steps_stability[[config_name]][[step_index]][[input$resolution]]$ecc

        color_ggplot(stab_obj[[1]]$embedding_list[[config_name]][[step_index]], ecc) +
          # ggplot2::guides(color = ggplot2::guide_legend(title = "ecc")) +
          ggplot2::scale_color_viridis_c(name = "ECC") +
          ggplot2::ggtitle(glue::glue("ECC distribution {config_name} - {step_index} for resolution {input$resolution}"))
      })

      output$overall_boxplot_ecc <- renderPlot({
        if (length(selected_configs()) == 0) {
          return(empty_ggplot())
        }

        if (is.null(current_feature_obj())) {
          return(empty_ggplot())
        }

        plot_feature_overall_stability_boxplot(current_feature_obj(),
          text_size = input$text_size,
          boxplot_width = input$boxplot_width,
          dodge_width = input$dodge_width
        )
      })

      output$overall_boxplot_incremental <- renderPlot({
        if (length(selected_configs()) == 0) {
          return(empty_ggplot())
        }

        if (is.null(current_feature_obj())) {
          return(empty_ggplot())
        }

        plot_feature_overall_stability_incremental(current_feature_obj(),
          text_size = input$text_size,
          boxplot_width = input$boxplot_width,
          dodge_width = input$dodge_width
        )
      })
    }
  )
}

server_dimensionality_distribution <- function(id) {
  moduleServer(
    id,
    function(input, output, session) {
      observeEvent(input$feature_type, {
        updateSelectInput(session,
          inputId = "feature_steps",
          choices = names(stab_obj[[1]]$steps_stability[[input$feature_type]])
        )
      })

      observeEvent(input$gene_expr, {
        updateSliderInput(session,
          inputId = "expr_threshold",
          max = round(max(expression_matrix[input$gene_expr, ]))
        )
      })

      output$umap_gene <- renderPlot({
        if (is.null(input$feature_type) || is.null(input$feature_steps)) {
          return(empty_ggplot())
        }

        embedding <- stab_obj$feature_importance$embedding_list[[input$feature_type]][[input$feature_steps]]

        if (length(input$gene_expr) == 0) {
          return(empty_ggplot())
        }

        if (is.null(embedding)) {
          return(empty_ggplot())
        }

        if (length(input$gene_expr) == 1) {
          expr_val <- expression_matrix[input$gene_expr, ]

          return(expression_ggplot(embedding, expr_val))
        }

        voting_scheme_ggplot(embedding, input$gene_expr, input$expr_threshold)
      })

      output$umap_metadata <- renderPlot({
        if (is.null(input$feature_type) || is.null(input$feature_steps)) {
          return(empty_ggplot())
        }

        embedding <- stab_obj$feature_importance$embedding_list[[input$feature_type]][[input$feature_steps]]

        if (is.null(embedding)) {
          return(empty_ggplot())
        }

        metadata_ggplot(embedding, input$metadata)
      })
    }
  )
}


server_dimensionality_recommendation <- function(id) {
  moduleServer(
    id,
    function(input, output, session) {
      observeEvent(input$radio_feature_type, {
        updateRadioButtons(
          session,
          label = "ASDA", # glue::glue("Choose the size of the feature set {input$radion_feature_type} for the downstream analysis: (We recommend {names(stab_obj[[input$radio_feature_type]])[1]}"),
          inputId = "radio_feature_size",
          choices = names(stab_obj[[input$radio_feature_type]]),
          selected = names(stab_obj[[input$radio_feature_type]])[1]
        )
      })


      v <- reactive(list(
        chosen_feature_type = input$radio_feature_type,
        chosen_set_size = input$radio_feature_size
      )) %>% bindEvent(input$fix_feature_button)

      # observeEvent(input$fix_feature_button, {
      #   v$chosen_feature_type <- input$radio_feature_type
      #   v$chosen_set_size <- input$radio_feature_size

      #   # print(v)
      #   # print(v$chosen_feature_type)
      #   # print(v$chosen_set_size)
      # })

      return(v)
    }
  )
}
```

```{r}
server_dimensionality_reduction <- function(id) {
  moduleServer(
    id,
    function(input, output, session) {
      server_dimensionality_stability("stability", "dim_reduc")
      server_dimensionality_distribution("distribution_left")
      server_dimensionality_distribution("distribution_right")
      recommendation <- server_dimensionality_recommendation("recommend")

      recommendation
    }
  )
}
```


```{r}
server_graph_clustering <- function(id, recommendation) {
  moduleServer(
    id,
    function(input, output, session) {
      chosen_object <- reactive(
        stab_obj[[recommendation()[[1]]]][[recommendation()[[2]]]]
      )

      stable_config <- reactive(
        chosen_object()$stable_config
      )

      clustering_importance <- reactive(
        chosen_object()$clustering_importance
      )

      output$selected_conf <- renderUI({
        h2("Please fix your choice of feature type and the size of the set from the 'Dimensionality reduction' tab!")
      })

      observe({
        output$selected_conf <- renderUI({
          fluidRow(
        div(glue::glue("Feature type: {stable_config()[[1]]}")),
        div(glue::glue("Feature set size: {stable_config()[[2]]}")),
        div(glue::glue("Base embedding: {stable_config()[[3]]}")),
        div(glue::glue("Graph type: {stable_config()[[4]]}")),
        div(glue::glue("Number of neighbours: {stable_config()[[5]]}"))
        )
      })

        output$header1 <- renderUI({
          h3("Boxplot distribution of the resolution-wise stability of the clustering methods")
        })

        output$header2 <- renderUI({
          h3("Boxplot distribution of the overall stability")
        })

        output$header3 <- renderUI({
          h3("Correspondence between the resolution value and the number of clusters")
        })

        output$header4 <- renderUI({
          h3("The stability of the number of clusters")
        })
      }) %>% bindEvent(recommendation())

      





      output$boxplot_per_value <- renderPlot({
        plot_clustering_per_value_stability(clustering_importance(),
          value_type = "resolution"
        )
      })

      output$boxplot_overall_resolution <- renderPlot({
        plot_clustering_overall_stability(clustering_importance(),
          value_type = "resolution"
        )
      })

      output$boxplot_overall_k <- renderPlot({
        plot_clustering_overall_stability(clustering_importance(),
          value_type = "k"
        )
      })

      output$k_resolution <- renderPlot({
        plot_k_resolution_corresp(clustering_importance(),
          colour_information = "ecc"
        )
      })

      output$k_stability <- renderPlot({
        plot_k_n_partitions(clustering_importance(),
          colour_information = "ecc"
        )
      })
    }
  )
}
```

```{r}
shiny_app <- function() {
  ui <- fluidPage(
    tags$head(
      tags$style(
        "#tabset_id {
        position: fixed;
        width: 100%;
        background-color: white;
        top: 0;
        z-index: 999;
        font-size: 25px;
        }",
        ".tab-content  {
        margin-top: 72px;
      }"
      )
    ),
    tabsetPanel(
      id = "tabset_id",
      ui_dimensionality_reduction("dim_reduc"),
      ui_graph_construction("graph_constr"),
      ui_graph_clustering("graph_clust")
    )
  )

  server <- function(input, output, session) {
    recommendation <- server_dimensionality_reduction("dim_reduc")
    server_graph_clustering("graph_clust", recommendation)
  }

  shinyApp(ui, server)
}
```

```{r}
shiny_app()
```

