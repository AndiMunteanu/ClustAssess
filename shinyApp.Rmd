
```{r}
library(shiny)
library(shinyWidgets)
library(ClustAssess)
library(ggplot2)
library(dplyr)
library(plotly)
library(RColorBrewer)
devtools::load_all()
```

```{r}
cList <- list(
  c(
    "grey85", "#FFF7EC", "#FEE8C8", "#FDD49E", "#FDBB84",
    "#FC8D59", "#EF6548", "#D7301F", "#B30000", "#7F0000"
  ),
  c(
    "#4575B4", "#74ADD1", "#ABD9E9", "#E0F3F8", "#FFFFBF",
    "#FEE090", "#FDAE61", "#F46D43", "#D73027"
  )[c(1, 1:9, 9)],
  c(
    "#FDE725", "#AADC32", "#5DC863", "#27AD81", "#21908C",
    "#2C728E", "#3B528B", "#472D7B", "#440154"
  )
)
names(cList) <- c("White-Red", "Blue-Yellow-Red", "Yellow-Green-Purple")
```

```{r}
load("expression_matrix.rda")
load("stab_obj.rda")
```

```{r}
```

```{r}
feature_config <- names(stab_obj$feature_importance$steps_stability)
steps <- lapply(feature_config, function(x) {
  names(stab_obj$feature_importance$steps_stability[[x]])
})
names(steps) <- feature_config
feature_config_display <- sapply(feature_config, function(x) {
  strsplit(x, "_")[[1]]
})

feature_config_display
strsplit(feature_config[1], "_")[[1]]
feature_used_resolution_vals <- names(stab_obj$feature_importance[[1]][[1]][[1]])
```

```{r}


# ui_dimensionality_reduction_inputs <- function(id) {
#   ns <- NS(id)
#
#   tagList(
#     selectInput(ns("feature_configs"), "Feature names", feature_config, selected = feature_config, multiple = TRUE),
#     sliderInput(ns("boxplot_width"), "Boxplot width", min = 0.00, max = 1.00, value = 0.40),
#     sliderInput(ns("dodge_width"), "Dodge width", min = 0.00, max = 1.00, value = 0.70),
#     sliderInput(ns("text_size"), "Text size", min = 0.10, max = 25.00, value = 4.00),
#   )
# }
#
# ui_dimensionali
#

ui_dimensionality_stability <- function(id) {
  ns <- NS(id)

  tagList(
    selectInput(ns("feature_configs"), "Feature names", feature_config, selected = feature_config, multiple = TRUE),
    uiOutput(ns("stepchoosing")),
    h2("ECC per individual resolution values"),
    fluidRow(
      column(
        8,
        plotOutput(ns("boxplot_ecc"),
          #   height = "40%",
          #   width = "50%",
          hover = hoverOpts(id = ns("ecc_hover"), delayType = "throttle"),
          click = ns("ecc_click")
        ),
      ),
      column(
        4,
        fluidRow(
          textOutput(ns("boxplot_ecc_info")),
          tableOutput(ns("table_ecc_info")),
          plotOutput(ns("umap_ecc"), height = "350px"),
        )
      )
    ),
    h2("Incremental ECS per individual resolution values"),
    fluidRow(
      column(
        8,
        plotOutput(ns("boxplot_incr"))
      ),
      column(
        4,
        sliderTextInput(ns("resolution"), "Resolution", choices = feature_used_resolution_vals, selected = feature_used_resolution_vals[1]),
        sliderInput(ns("boxplot_width"), "Boxplot width", min = 0.00, max = 1.00, value = 0.40),
        sliderInput(ns("dodge_width"), "Dodge width", min = 0.00, max = 1.00, value = 0.70),
        sliderInput(ns("text_size"), "Text size", min = 0.10, max = 25.00, value = 4.00),
      )
    ),
    hr(),
    h2("Overall stability"),
    plotOutput(ns("overall_boxplot_ecc")),
    h2("Overall incremental stability"),
    plotOutput(ns("overall_boxplot_incremental"))
  )
}

ui_dimensionality_distribution_plots <- function(id) {
  ns <- NS(id)

  tagList(
    selectInput(ns("feature_type"), "Feature names", feature_config),
    selectInput(ns("feature_steps"), "Feature set size", NULL),
    hr(),
    fluidRow(
      column(
        6,
        selectInput(ns("gene_expr"), "Gene name(s)", choices = rownames(expression_matrix)[1:3000], selected = rownames(expression_matrix)[1], multiple = TRUE)
      ),
      column(
        6,
        conditionalPanel(
          condition = "input.gene_expr.length > 1",
          sliderInput(ns("expr_threshold"), "Gene expression threshold", min = 0, max = 10, value = 0.1),
          ns = ns
        )
      )
    ),
    plotOutput(ns("umap_gene")),
    plotOutput(ns("umap_metadata"))
  )
}
```

```{r}
ui_dimensionality_reduction <- function(id) {
  ns <- NS(id)

  tabPanel(
    "Dimensionality Reduction",
    h2("Assessing the stability of the dimensionality reduction"),
    ui_dimensionality_stability(ns("stability")),
    fluidRow(
      column(
        6,
        ui_dimensionality_distribution_plots(ns("distribution_left"))
      ),
      column(
        6,
        ui_dimensionality_distribution_plots(ns("distribution_right"))
      )
    )
  )
}

ui_graph_construction <- function(id) {
  ns <- NS(id)

  tabPanel(
    "Graph Construction",
    h2("asdf")
  )
}

ui_graph_clustering <- function(id) {
  ns <- NS(id)

  tabPanel(
    "Graph Clustering",
    h2("Assessing the stability of the graph clustering"),
    h3("Boxplot distribution of the resolution-wise stability of the clustering methods"),
    fluidRow(
      column(
        8,
        plotOutput(ns("boxplot_per_value")),
      ),
      column(
        4,
        plotOutput(ns("umap_config"))
      )
    ),
    h3("Boxplot distribution of the overall stability"),
    fluidRow(
      column(6,
        plotOutput(ns("boxplot_overall_resolution"))
      ),
      column(6,
      plotOutput(ns("boxplot_overall_k"))
      )
    ),
    h3("Correspondence between the resolution value and the number of clusters"),
    plotOutput(ns("k_resolution")),
    h3("The stability of the number of clusters"),
    plotOutput(ns("k_stability"))
  )
}
```

```{r, fig.width=10, fig.height = 6}
```
```{r}
```


```{r}
server_dimensionality_stability <- function(id, panel_id) {
  moduleServer(
    id,
    function(input, output, session) {
      selected_configs <- reactive(input$feature_configs)

      ecc_mouse_hover <- reactiveVal(c(NA, NA))
      observeEvent(input$ecc_hover, {
        # FIXME for far right values, it doesn't detect a step
        if (is.null(input$ecc_hover)) {
          return()
        }
        x <- input$ecc_hover$x
        # y <- input$ecc_hover$y
        min_step <- min(as.numeric(boxplot_ecc_df()$step_index))
        max_step <- max(as.numeric(boxplot_ecc_df()$step_index))
        nconfigs <- length(selected_configs())
        chosen_step <- NULL
        chosen_config <- NULL

        for (steps_intervals in seq(from = min_step - 0.5, to = max_step + 0.5, by = 1)) {
          if (x < steps_intervals + 1) {
            chosen_step <- steps_intervals + 0.5
            break
          }
        }

        if (is.null(chosen_step)) {
          chosen_step <- max_step
        }

        for (i in seq_len(nconfigs)) {
          if (x < (steps_intervals + i / nconfigs)) {
            chosen_config <- i
            break
          }
        }

        if (is.null(chosen_config)) {
          chosen_config <- nconfigs
        }

        ecc_mouse_hover(c(chosen_step, chosen_config))
      })

      ecc_mouse_click <- reactiveVal(c(NA, NA))

      observeEvent(input$ecc_click, {
        if (!is.null(input$ecc_click)) {
          ecc_mouse_click(ecc_mouse_hover())
        }
      })

      output$boxplot_ecc_info <- renderText({
        if (is.na(ecc_mouse_hover()[1])) {
          return()
        }

        feature_type <- names(current_feature_obj()$steps_stability)[ecc_mouse_hover()[2]]
        nfeatures <- names(current_feature_obj()$steps_stability[[ecc_mouse_hover()[2]]])[ecc_mouse_hover()[1]]
        glue::glue("The ECC summary for {feature_type} - {nfeatures} and resolution {input$resolution}.
        Click if you want to visualise the UMAP distribution.")
      })

      output$table_ecc_info <- renderTable({
        if (is.na(ecc_mouse_hover()[1])) {
          return()
        }
        summary_ecc <- fivenum(current_feature_obj()$steps_stability[[ecc_mouse_hover()[2]]][[ecc_mouse_hover()[1]]][[input$resolution]]$ecc)
        data.frame(
          min = summary_ecc[1],
          Q1 = summary_ecc[2],
          median = summary_ecc[3],
          Q3 = summary_ecc[4],
          max = summary_ecc[5]
        )
      })

      output$stepchoosing <- renderUI({
        ns <- session$ns
        i <- 1
        ret_list <- list()
        for (conf in input$feature_configs) {
          ret_list[[i]] <- selectInput(ns(paste0("nsteps_", i)), # paste(panel_id, id, paste0("nsteps_", i), sep = "-"),
            paste("Nsteps for", conf),
            choices = names(stab_obj$feature_importance$steps_stability[[conf]]),
            selected = names(stab_obj$feature_importance$steps_stability[[conf]]),
            multiple = TRUE
          )
          i <- i + 1
        }
        ret_list
      })

      current_feature_obj <- reactive({
        steps_stability <- lapply(seq_along(selected_configs()), function(i) {
          steps_names <- names(stab_obj$feature_importance$steps_stability[[i]])
          chosen_steps <- steps_names %in% input[[paste0("nsteps_", i)]]
          chosen_steps <- steps_names[chosen_steps]
          stab_obj$feature_importance$steps_stability[[i]][chosen_steps]
        })
        names(steps_stability) <- selected_configs()

        incremental_stability <- lapply(seq_along(selected_configs()), function(i) {
          kept_steps <- c()
          chosen_steps <- input[[paste0("nsteps_", i)]]

          for (j in seq_len(length(chosen_steps) - 1)) {
            checked_steps <- paste(chosen_steps[j], chosen_steps[j + 1], sep = "-")
            if (checked_steps %in% names(stab_obj$feature_importance$incremental_stability[[i]])) {
              kept_steps <- c(kept_steps, checked_steps)
            }
          }

          stab_obj$feature_importance$incremental_stability[[i]][kept_steps]
        })
        names(incremental_stability) <- selected_configs()

        list(
          steps_stability = steps_stability,
          incremental_stability = incremental_stability
        )
      })

      boxplot_ecc_df <- reactive({
        plot_feature_per_resolution_stability_boxplot(current_feature_obj(),
          resolution = input$resolution,
          return_df = TRUE
        )
      })

      output$boxplot_ecc <- renderPlot({
        if (length(selected_configs()) == 0) {
          return(ggplot2::ggplot() +
            ggplot2::theme_void())
        }
        plot_feature_per_resolution_stability_boxplot(current_feature_obj(),
          resolution = input$resolution,
          text_size = input$text_size,
          boxplot_width = input$boxplot_width,
          dodge_width = input$dodge_width
        )
      })

      output$boxplot_incr <- renderPlot({
        if (length(selected_configs()) == 0) {
          return(ggplot2::ggplot() +
            ggplot2::theme_void())
        }

        for (conf in selected_configs()) {
          if (length(names(current_feature_obj()$incremental_stability[[conf]])) == 0) {
            return(ggplot2::ggplot() +
              ggplot2::theme_void())
          }
        }
        plot_feature_per_resolution_stability_incremental(current_feature_obj(),
          resolution = input$resolution,
          text_size = input$text_size,
          boxplot_width = input$boxplot_width,
          dodge_width = input$dodge_width
        )
      })

      output$umap_ecc <- renderPlot({
        if (is.na(ecc_mouse_click()[1])) {
          return(ggplot2::ggplot() +
            ggplot2::theme_void())
        }

        config_name <- selected_configs()[ecc_mouse_click()[2]]
        step_index <- names(current_feature_obj()$steps_stability[[config_name]])[ecc_mouse_click()[1]]
        ecc <- current_feature_obj()$steps_stability[[config_name]][[step_index]][[input$resolution]]$ecc

        print(config_name)
        print(step_index)

        ggplot2::ggplot(
          data.frame(
            stab_obj[[1]]$embedding_list[[config_name]][[step_index]]
          ),
          aes(
            x = .data$UMAP_1,
            y = .data$UMAP_2,
            color = ecc
          )
        ) +
          ggplot2::geom_point() +
          ggplot2::scale_color_viridis_c() +
          ggplot2::theme_bw() +
          ggplot2::ggtitle(glue::glue("ECC distribution {config_name} - {step_index} for resolution {input$resolution}"))
      })

      output$overall_boxplot_ecc <- renderPlot({
        if (length(selected_configs()) == 0) {
          return(ggplot2::ggplot() +
            ggplot2::theme_void())
        }
        plot_feature_overall_stability_boxplot(current_feature_obj(),
          text_size = input$text_size,
          boxplot_width = input$boxplot_width,
          dodge_width = input$dodge_width
        )
      })

      output$overall_boxplot_incremental <- renderPlot({
        if (length(selected_configs()) == 0) {
          return(ggplot2::ggplot() +
            ggplot2::theme_void())
        }
        plot_feature_overall_stability_incremental(current_feature_obj(),
          text_size = input$text_size,
          boxplot_width = input$boxplot_width,
          dodge_width = input$dodge_width
        )
      })

      output$con_name <- renderText(paste("test", paste(names(current_feature_obj()$steps_stability), collapse = " ")))
    }
  )
}

server_dimensionality_distribution <- function(id) {
  moduleServer(
    id,
    function(input, output, session) {
      observeEvent(input$feature_type, {
        updateSelectInput(session,
          inputId = "feature_steps",
          choices = names(stab_obj[[1]]$steps_stability[[input$feature_type]])
        )
      })

      observeEvent(input$gene_expr, {
        updateSliderInput(session,
          inputId = "expr_threshold",
          max = round(max(expression_matrix[input$gene_expr, ]))
        )
      })

      output$umap_gene <- renderPlot({
        embedding <- stab_obj$feature_importance$embedding_list[[input$feature_type]][[input$feature_steps]]

        if (length(input$gene_expr) == 0) {
          return(ggplot2::ggplot() +
            ggplot2::theme_void())
        }

        if (length(input$gene_expr) == 1) {
          expr_val <- expression_matrix[input$gene_expr, ]
          return(
            ggplot2::ggplot(
              data.frame(embedding),
              aes(x = .data$UMAP_1, y = .data$UMAP_2, color = expr_val)
            ) +
              ggplot2::geom_point() +
              ggplot2::theme_bw() +
              ggplot2::scale_color_gradientn("", colors = cList[[1]]) +
              ggplot2::guides(color = ggplot2::guide_colorbar(barwidth = 15)) +
              ggplot2::theme(legend.position = "bottom")
          )
        }

        n_expressed_genes <- rep(0, ncol(expression_matrix))
        threshold <- as.numeric(input$expr_threshold)
        for (gene in input$gene_expr) {
          n_expressed_genes <- n_expressed_genes + (expression_matrix[gene, ] > threshold)
        }

        mask <- (n_expressed_genes >= length(input$gene_expr))
        # print(input$gene_expr)
        # print(summary(mask))
        umap_df <- data.frame(embedding)
        print(colnames(umap_df))

        ggplot2::ggplot() +
          ggplot2::geom_point(
            data = umap_df[!mask, ],
            mapping = aes(x = .data$UMAP_1, .data$UMAP_2),
            color = "#C3C3C3"
          ) +
          ggplot2::geom_point(
            data = umap_df[mask, ],
            mapping = aes(x = .data$UMAP_1, .data$UMAP_2),
            color = "red"
          ) +
          ggplot2::theme_bw()
      })
      # output$stepchoosing <- renderUI({
      #   ns <- session$ns

      #   selectInput(ns(), # paste(panel_id, id, paste0("nsteps_", i), sep = "-"),
      #       paste("Nsteps for", conf),
      #       choices = names(stab_obj$feature_importance$steps_stability[[conf]]),
      #       selected = names(stab_obj$feature_importance$steps_stability[[conf]]),
      #       multiple = TRUE
      #     )
      #     i <- i + 1
      #   }
      #   ret_list
      # })
    }
  )
}
```

```{r}
server_dimensionality_reduction <- function(id) {
  moduleServer(
    id,
    function(input, output, session) {
      server_dimensionality_stability("stability", "dim_reduc")
      server_dimensionality_distribution("distribution_left")
      server_dimensionality_distribution("distribution_right")
    }
  )
}
```


```{r}
server_graph_clustering <- function(id) {
  moduleServer(
    id,
    function(input, output, session) {
      output$boxplot_per_value <- renderPlot({
        plot_clustering_per_value_stability(stab_obj[[2]][[1]]$clustering_importance,
        value_type = "resolution")
      })
      
      output$boxplot_overall_resolution <- renderPlot({
        plot_clustering_overall_stability(stab_obj[[2]][[1]]$clustering_importance,
          value_type = "resolution"
        )
      })

      output$boxplot_overall_k <- renderPlot({
        plot_clustering_overall_stability(stab_obj[[2]][[1]]$clustering_importance,
          value_type = "k"
        )
      })
      
      output$k_resolution <- renderPlot({
        plot_k_resolution_corresp(stab_obj[[2]][[1]]$clustering_importance,
        colour_information = "ecc")
      })

      output$k_stability <- renderPlot({
        plot_k_n_partitions(stab_obj[[2]][[1]]$clustering_importance,
         colour_information = "ecc")
      })
    }
  )
}

```

```{r}
shiny_app <- function() {
  ui <- fluidPage(
    tags$head(
    tags$style(
      "#tabset_id {
        position: fixed;
        width: 100%;
        background-color: white;
        top: 0;
        z-index: 999;
        font-size: 25px;
        }",
      ".tab-content  {
        margin-top: 72px;
      }"
    )
  ),
    tabsetPanel(
      id = "tabset_id",
      ui_dimensionality_reduction("dim_reduc"),
      ui_graph_construction("graph_constr"),
      ui_graph_clustering("graph_clust")
    )
  )

  server <- function(input, output, session) {
    server_dimensionality_reduction("dim_reduc")
    server_graph_clustering("graph_clust")
  }

  shinyApp(ui, server)
}
```

```{r}
shiny_app()
```

